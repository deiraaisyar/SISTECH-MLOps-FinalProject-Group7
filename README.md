# Recommendation Engine for Jobs, Courses, Majors, Career, and Job Articles

# Overview
This project builds a comprehensive recommendation engine designed to guide users in exploring suitable jobs, educational courses, university majors, career paths, and job-related articles. By integrating diverse datasets and utilizing text-based similarity techniques, the system helps users navigate through various options based on their interests or background. The goal is to provide a more personalized and informative experience for individuals making academic or career decisions, especially students or fresh graduates. The recommendation results are generated by analyzing both user inputs and content features, ensuring relevant and practical suggestions across different domains.

---
## Features
- Career recommendation based on userâ€™s RIASEC result, interests, and skills
- Job recommendation based on career match
- Course & Certification recommendations based on career match
- Majors & University recommendations based on career match
- Career outlook & articles

---
## Scraping Methods & Data Sources

The scraping methods in this project involve collecting data from various online sources to build a comprehensive dataset for recommendations. The key scraping processes include:

1. **Job Data**:
   - Source: LinkedIn Job API
   - Method: Web scraping using tools like BeautifulSoup and Selenium to extract job postings, descriptions, and requirements.

2. **Course Data**:
   - Source: edX API
   - Method: API integration and web scraping to gather course details, including titles, descriptions, and learning outcomes.

3. **University Majors**:
   - Source: BAN-PT and QS World University Rankings 2026
   - Method: Scraping major offerings, program details, and rankings.

4. **Career Articles**:
   - Source: Google Custom Search API
   - Method: Fetching articles related to career trends, job market outlook, and employment forecasts.

5. **Career Data**:
   - Source: O*NET Online
   - Method: API integration to fetch career data, including job descriptions, required skills, and career outlooks based on RIASEC scores.

These scraping methods ensure that the dataset remains up-to-date and relevant for generating accurate recommendations.

---
## Vectorization
The vectorization process in this project uses Sentence Transformers, a state-of-the-art model for generating dense vector representations of text. This method is particularly effective for capturing semantic meaning, making it ideal for tasks like recommendation systems. The steps include:

1. **Text Embedding**: Input text data is converted into dense vector representations using the Sentence Transformers model (`all-MiniLM-L6-v2`).
2. **Normalization**: The generated vectors are normalized to unit length to ensure consistency in cosine similarity calculations.
3. **Storage**: The embeddings are stored in a FAISS index, which allows for efficient similarity searches and retrievals.

---
## Vector Database

The vector database in this project is implemented using FAISS (Facebook AI Similarity Search), a library designed for efficient similarity search and clustering of dense vectors. It is used to store and retrieve vectorized representations of text data, enabling fast and accurate similarity calculations. The key features include:

1. **Indexing**: The dense vector representations generated during the vectorization process are stored in a FAISS index. This index allows for efficient similarity searches using methods like cosine similarity.
2. **Storage**: The FAISS index is saved to disk, ensuring that it can be quickly loaded and reused without the need to recompute embeddings.
3. **Scalability**: FAISS is optimized for handling large-scale datasets, making it suitable for this project's diverse and extensive data sources.

By leveraging FAISS, the system ensures that recommendations are generated quickly and accurately, even when dealing with large volumes of data.

---
## Similarity

The similarity calculation in this project is based on cosine similarity, a metric that measures the cosine of the angle between two vectors in a multi-dimensional space. This approach is particularly effective for comparing text embeddings generated by models like Sentence Transformers. The steps include:

1. **Embedding Comparison**: The embeddings of the query text and the dataset are compared.
2. **Cosine Similarity Formula**: The similarity score is calculated using the formula:
   \[
   \text{similarity}(A, B) = \frac{A \cdot B}{\|A\| \|B\|}
   \]
   where \(A\) and \(B\) are the embedding vectors.
3. **Ranking**: The results are ranked based on their similarity scores, with higher scores indicating greater relevance.

---
## API
1. O*NET Web Services API:

Used for career recommendations based on RIASEC scores.

Endpoints:
- /ws/mnm/interestprofiler/careers: Fetches careers matching the RIASEC scores.
- /ws/mnm/careers/{career_code}/report: Retrieves detailed reports for specific careers.
- Requires authentication using a username and password, encoded in the request headers.

2. Google Custom Search API:

Used to fetch job-related articles and trends.

Endpoint:
- /customsearch/v1: Searches for articles based on a query string.

Requires an API key and a search engine ID for authentication.

---
## Running the Application

To run the application, use the following command:

```bash
uvicorn main:app --reload
```

This will start the FastAPI application and make it accessible at `http://127.0.0.1:8000`.

## Testing the Endpoints

Once the application is running, you can test the following endpoints:

- **`/recommend-careers`**: Accepts RIASEC scores and returns career recommendations.
  - Example: `http://127.0.0.1:8000/recommend-careers`

- **`/recommend-jobs`**: Accepts a query string and returns job recommendations.
  - Example: `http://127.0.0.1:8000/recommend-jobs`

- **`/recommend-courses`**: Accepts a query string and returns course recommendations.
  - Example: `http://127.0.0.1:8000/recommend-courses`

- **`/recommend-programs`**: Accepts a query string and returns university major or program recommendations.
  - Example: `http://127.0.0.1:8000/recommend-programs`

- **`/get-job-articles`**: Accepts a query string and returns job-related articles.
  - Example: `http://127.0.0.1:8000/get-job-articles`

- **`/health`**: A health check endpoint to verify the API is running.
  - Example: `http://127.0.0.1:8000/health`

---
## Evaluation

The evaluation process in this project compares various methods for generating recommendations based on their relevance to the input query. The methods evaluated include traditional approaches like Bag of Words (BoW) and TF-IDF, as well as modern techniques like Word2Vec, FastText, and Sentence Transformers. The key findings are:

1. **Traditional Methods**:
   - BoW and TF-IDF performed well in identifying relevant results but were limited by their reliance on word frequency and lack of semantic understanding.
   - Both methods occasionally recommended irrelevant results due to the presence of frequently occurring words in the input text.

2. **Modern Methods**:
   - **Word2Vec**: Performed better than traditional methods, especially when using Word Mover's Distance (WMD) for similarity calculations. However, it sometimes introduced less relevant results when using cosine similarity.
   - **FastText**: Delivered similar performance to Word2Vec with WMD but required more computational resources.
   - **Sentence Transformers**: Outperformed all other methods by capturing semantic meaning effectively. It was the only method that consistently excluded irrelevant results, such as courses unrelated to the input context.

3. **Conclusion**:
   - Sentence Transformers with cosine similarity is the best-performing method. Its ability to understand the context and semantics of the input text ensures highly relevant recommendations.
   - To optimize response time, the model and its precomputed embeddings are saved in advance for quick loading during API calls.

---
## Contributors
- Amelia Wibisono
- Deira Aisya Refani